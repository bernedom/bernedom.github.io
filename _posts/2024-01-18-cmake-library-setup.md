---
layout: post
title: CMake line by line - Creating a library
description: "How to set up a library with CMake, including proper symbol visibility and installation"
thumbnail: images/cmake-logo.png
---

**Creating a library with CMake is simple. To make it easy portable, we will also add proper symbol visibility and installation.** 
CMake is arguably one of the most popular build systems for C++ projects and many open source projects and companies use it. Creating a library is as simple as invoking the `add_library()` command and adding the sources to it. However, there are a few things to consider when creating a library with CMake. In this post, we will go through the steps to create a library with CMake, including proper symbol visibility and installation. All the code for this post is available as [a template on GitHub](https://github.com/bernedom/CMake_Library_Template)

## Creating a library in a nutshell

When configuring for a library with CMake we need to do the following things:

1. Creating the library and adding the sources to it
2. Setting version compatibility
3. Specifying which include files are public and private
4. Setting symbol visibility and creating an export header
5. Defining where to install the library and make it usable with `find_package()`
6. Some miscellaneous things like setting the C++ standard and debug suffix

For detailed documentation on the commands used in this post, please refer to the [CMake documentation](https://cmake.org/cmake/help/latest/).

{% include cmake-best-practices-ad.html %}

## Setting up the project

Choosing the right file structure for a project is alsways important. It makes it easier to find files and helps to keep the project organized. For libraries it is even more important, because choosing the right structure makes it easier for others to use the library and to only install the files that are needed. For this post, we will create a library called "Greeter" or "libGreeter" and use the following file structure:


```bash
├── CMakeLists.txt # the main CMakeLists.txt file
├── LICENSE
├── README.md
├── cmake # CMake modules
│   └── GreeterConfig.cmake.in
├── include # public headers
│   └── greeter
│       └── hello.hpp
└── src # source files
    ├── hello.cpp
    ├── internal.cpp
    └── internal.hpp
```

The library will expose a class `Greeter::Hello` that contains a `greet()` function that prints "Hello <name> from a library". This class is declared in the `include/hello/hello.hpp`. Internally it uses a private function called `print_impl` which is defined in The `internal.cpp` and `internal.hpp` files are used to demonstrate how to hide symbols from the library interface. The `GreeterConfig.cmake.in` file is used to configure the CMake package file that will be used to make the library usable with `find_package()`.

Let's have a look at the public header file `include/greeter/hello.hpp`:

```cpp
#pragma once

#include <greeter/export_greeter.hpp>
#include <string>

namespace Greeter {
/// Example class that is explicitly exported into a library
class GREETER_EXPORT Hello {
public:
  Hello(const std::string &name) : name_{name} {}

  void greet() const;

private:
  const std::string name_;
};
} // namespace Greeter
```

Two things are notable in this class, first, the including of the `<greeter/export_header.hpp>` file and second, the `GREETER_EXPORT` macro. The `export_greeter.hpp` file is generated by CMake and contains the necessary macros to export symbols from the library. The `GREETER_EXPORT` macro is used to mark the class as exported. This makes the class visible to users of the library and marks the class `Greeter::Hello` as part of the public API. The export header is generated by CMake and we will look at it later.

## Creating the library with CMake

Let's have a look at the `CMakeLists.txt` file line by line.

<details>
<summary markdown="span">
Click here to expand the full FindLibrary.cmake
</summary>

```CMake
cmake_minimum_required(VERSION 3.17)

project(
    Greeter
    VERSION 1.0.0
    DESCRIPTION
        "A simple C++ project to demonstrate creating executables and libraries in CMake"
    LANGUAGES CXX
)

# set the postfix "d" for the resulting .so or .dll files when building the
# library in debug mode
set(CMAKE_DEBUG_POSTFIX
    d
)

# add the library target
add_library(Greeter)

# set properties for the target. VERSION set the library version to the project
# version * SOVERSION set the compatibility  version for the library to the
# major number of the version
set_target_properties(
    Greeter
    PROPERTIES VERSION ${PROJECT_VERSION}
               SOVERSION ${PROJECT_VERSION_MAJOR}
)

# add sources to the library target
target_sources(
    Greeter
    PRIVATE src/hello.cpp src/internal.cpp
)

# define the C++ standard needed to compile this library and make it visible to
# dependers
target_compile_features(
    Greeter
    PUBLIC cxx_std_17
)

# set the include directories
target_include_directories(
    Greeter
    PRIVATE src
    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

# if using limited visibility, set CXX_VISIBILILTY_PRESET to "hidden"
include(GenerateExportHeader)
set_property(
    TARGET Greeter
    PROPERTY CXX_VISIBILITY_PRESET "hidden"
)
# Hide inlined functions by default, reducing the size of the library
set_property(
    TARGET Greeter
    PROPERTY VISIBILITY_INLINES_HIDDEN TRUE
)
# this command generates a header file in the CMAKE_CURRENT_BINARY_DIR which
# sets the visibility attributes according to the compiler settings
generate_export_header(
    Greeter
    EXPORT_FILE_NAME
    export/greeter/export_greeter.hpp
)
# Add CMAKE_CURRENT_BINARY_DIR to the include path so the generated header can
# be found
target_include_directories(
    Greeter
    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/export>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
    
)

# include the GNUInstallDirs module to get the canonical install paths defined
include(GNUInstallDirs)

# Install the library and export the CMake targets
install(
    TARGETS Greeter
    EXPORT GreeterTargets
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)
# install the public headers
install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

# install the generated export header
install(
    FILES "${CMAKE_CURRENT_BINARY_DIR}/export/greeter/export_greeter.hpp"
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/greeter
)

# configure the CMake package file so the libray can be included with find_package() later
include(CMakePackageConfigHelpers)

write_basic_package_version_file(
    "GreeterConfigVersion.cmake"
    VERSION ${PROJECT_VERSION}
    COMPATIBILITY SameMajorVersion)

configure_package_config_file(
    "${CMAKE_CURRENT_LIST_DIR}/cmake/GreeterConfig.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/GreeterConfig.cmake"
    INSTALL_DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/cmake/greeter
)

# install the CMake targets
install(
    EXPORT GreeterTargets
    FILE GreeterTargets.cmake
    NAMESPACE Greeter::
    DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/cmake/greeter
)
```
</details>

As usual the `CMakeLists.txt` starts with `cmake_minimum_required` which specifies the minimum CMake version to be used and the `project()` call. 

```CMake 
project(
    Greeter
    VERSION 1.0.0
    DESCRIPTION
        "A simple C++ project to demonstrate creating executables and libraries in CMake"
    LANGUAGES CXX
)
```

For libraries the `VERSION` field is important, as this is used to determine the version compatibility of the library. The `LANGUAGES` field is optional, but it is good practice to specify the language used in the project. This will make sure that the correct compiler is used when building the project.

The next thing to do is to set a debug postfix for the library with `set(CMAKE_DEBUG_POSTFIX d)`. This means when building the library in debug mode, it will append a "d" to the resulting library file. This is useful to distinguish between debug and release builds of the library, but it is an optional step. This is a global option for the project, so it will affect all libraries and executables inside the project. 

After that the library target is created with `add_library(Greeter)`. This will create a library target called `Greeter` which can be used to add sources, set properties and link against other libraries. 

Once the target is defined we can set the properties for the library. 

```CMake
set_target_properties(
    Greeter
    PROPERTIES VERSION ${PROJECT_VERSION}
               SOVERSION ${PROJECT_VERSION_MAJOR}
)
```

The `VERSION` property sets the version of the library to the project version. The `SOVERSION` property sets the compatibility version of the library to the major version of the project. Generally you should try to use [semantic versioning](https://semver.org/) for libraries and set the `SOVERSION` to the major version of the library and determines API compatibility. Generally I advise to use the following rules for versioning:

* If your change the public API by removing or changing an interface class or function, increase the major version
* If new symbols are added to the API but nothing is changed or remove increase the minor version
* For implementation changes that do not affect the API increase the patch version

Once the target is created and the properties are set, we can add the sources to the library target with `target_sources()`. This command takes the target name and a list of source files and adds them to the target. The sources are added as private sources, which means they are only visible to the target itself. This is important to hide implementation details from the library interface. 

Next we need to set up the include directories for the library. For the public include directories, there are two things to consider here, first the headers need to be available to the library itself and second, the headers need to be available to users of the library. This makes the `target_include_directories()` command a bit more complicated. 

```CMake
target_include_directories(
    Greeter
    PRIVATE src
    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)
```

This command takes the target name and a list of include directories. The `PRIVATE` keyword means that the include directory is only visible to the target itself. We add the `src` folder here which contains all the internal headers/
The `PUBLIC` keyword means that the include directory is visible to the target and to users of the library, to differ the include path during building the library and when it is installed, a [generator expression](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html) is used. If we're building the library itself the `$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>` expression will be evaluated to the `include` folder in the source directory. If the library is installed, the expression `$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>` will be evaluated to the install include directory. This makes sure that the correct include directory is used when building the library and when it is installed.

Separating the headers into private and public is one step to define the library interface, we can go a step further by defining the symbol visibility of the library. This is important to hide implementation details from the library interface and to reduce the size of the library. CMake has a built-in module called `GenerateExportHeader` that can be used to generate a header file that sets the symbol visibility according to the compiler settings, which is included with `include(GenerateExportHeader)`. 

Next we set the default visibility of the library to hidden with `set_property(TARGET Greeter PROPERTY CXX_VISIBILITY_PRESET "hidden")`. This means that all symbols are hidden by default and need to be explicitly exported. On Windows this is already the default, on linux und mac the default is that everything is visible. Additionally we can hide inlined functions with `set_property(TARGET Greeter PROPERTY VISIBILITY_INLINES_HIDDEN TRUE)`. This will reduce the size of the library some more but it also means that inlined functions need to be explicitly exported.



```CMake

# add sources to the library target
target_sources(
    Greeter
    PRIVATE src/hello.cpp src/internal.cpp
)


# set the include directories
target_include_directories(
    Greeter
    PRIVATE src
    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

# if using limited visibility, set CXX_VISIBILILTY_PRESET to "hidden"
include(GenerateExportHeader)
set_property(
    TARGET Greeter
    PROPERTY CXX_VISIBILITY_PRESET "hidden"
)
# Hide inlined functions by default, reducing the size of the library
set_property(
    TARGET Greeter
    PROPERTY VISIBILITY_INLINES_HIDDEN TRUE
)
# this command generates a header file in the CMAKE_CURRENT_BINARY_DIR which
# sets the visibility attributes according to the compiler settings
generate_export_header(
    Greeter
    EXPORT_FILE_NAME
    export/greeter/export_greeter.hpp
)
# Add CMAKE_CURRENT_BINARY_DIR to the include path so the generated header can
# be found
target_include_directories(
    Greeter
    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/export>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
    
)

# include the GNUInstallDirs module to get the canonical install paths defined
include(GNUInstallDirs)

# Install the library and export the CMake targets
install(
    TARGETS Greeter
    EXPORT GreeterTargets
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)
# install the public headers
install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})

# install the generated export header
install(
    FILES "${CMAKE_CURRENT_BINARY_DIR}/export/greeter/export_greeter.hpp"
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/greeter
)

# configure the CMake package file so the libray can be included with find_package() later
include(CMakePackageConfigHelpers)

write_basic_package_version_file(
    "GreeterConfigVersion.cmake"
    VERSION ${PROJECT_VERSION}
    COMPATIBILITY SameMajorVersion)

configure_package_config_file(
    "${CMAKE_CURRENT_LIST_DIR}/cmake/GreeterConfig.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/GreeterConfig.cmake"
    INSTALL_DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/cmake/greeter
)

# install the CMake targets
install(
    EXPORT GreeterTargets
    FILE GreeterTargets.cmake
    NAMESPACE Greeter::
    DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/cmake/greeter
)
```